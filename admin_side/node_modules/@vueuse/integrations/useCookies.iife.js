;(function (window) {
  if (window.VueDemi) {
    return
  }
  var VueDemi = {}
  var Vue = window.Vue
  if (Vue) {
    if (Vue.version.slice(0, 2) === '2.') {
      var VueCompositionAPI = window.VueCompositionAPI
      if (VueCompositionAPI) {
        for (var key in VueCompositionAPI) {
          VueDemi[key] = VueCompositionAPI[key]
        }
        VueDemi.isVue2 = true
        VueDemi.isVue3 = false
        VueDemi.install = function (){}
        VueDemi.Vue = Vue
        VueDemi.Vue2 = Vue
        VueDemi.version = Vue.version
      } else {
        console.error(
          '[vue-demi] no VueCompositionAPI instance found, please be sure to import `@vue/composition-api` before `vue-demi`.'
        )
      }
    } else if (Vue.version.slice(0, 2) === '3.') {
      for (var key in Vue) {
        VueDemi[key] = Vue[key]
      }
      VueDemi.isVue2 = false
      VueDemi.isVue3 = true
      VueDemi.install = function (){}
      VueDemi.Vue = Vue
      VueDemi.Vue2 = undefined
      VueDemi.version = Vue.version
      VueDemi.set = function(target, key, val) {
        if (Array.isArray(target)) {
          target.length = Math.max(target.length, key)
          target.splice(key, 1, val)
          return val
        }
        target[key] = val
        return val
      }
      VueDemi.del = function(target, key) {
        if (Array.isArray(target)) {
          target.splice(key, 1)
          return
        }
        delete target[key]
      }
    } else {
      console.error('[vue-demi] Vue version ' + Vue.version + ' is unsupported.')
    }
  } else {
    console.error(
      '[vue-demi] no Vue instance found, please be sure to import `vue` before `vue-demi`.'
    )
  }
  window.VueDemi = VueDemi
})(window)
;
;(function (exports, shared, vueDemi, Cookie) {
  'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Cookie__default = /*#__PURE__*/_interopDefaultLegacy(Cookie);

  /**
   * Creates a new {@link useCookies} function
   * @param {Object} req - incoming http request (for SSR)
   * @see https://github.com/reactivestack/cookies/tree/master/packages/universal-cookie universal-cookie
   * @description Creates universal-cookie instance using request (default is window.document.cookie) and returns {@link useCookies} function with provided universal-cookie instance
   */
  function createCookies(req) {
      const universalCookie = new Cookie__default['default'](req ? req.headers.cookie : null);
      return (dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}) => useCookies(dependencies, { doNotParse, autoUpdateDependencies }, universalCookie);
  }
  /**
   * Reactive methods to work with cookies (use {@link createCookies} method instead if you are using SSR)
   * @param {string[]|null|undefined} dependencies - array of watching cookie's names. Pass empty array if don't want to watch cookies changes.
   * @param {Object} options
   * @param {boolean} options.doNotParse - don't try parse value as JSON
   * @param {boolean} options.autoUpdateDependencies - automatically update watching dependencies
   * @param {Object} cookies - universal-cookie instance
   */
  function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookie__default['default']()) {
      const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
      let previousCookies = cookies.getAll({ doNotParse: true });
      /**
       * Adds reactivity to get/getAll methods
       */
      const touches = vueDemi.ref(0);
      const onChange = () => {
          const newCookies = cookies.getAll({ doNotParse: true });
          if (shouldUpdate(watchingDependencies || null, newCookies, previousCookies))
              touches.value++;
          previousCookies = newCookies;
      };
      shared.tryOnMounted(() => {
          cookies.addChangeListener(onChange);
      });
      shared.tryOnUnmounted(() => {
          cookies.removeChangeListener(onChange);
      });
      return {
          /**
           * Reactive get cookie by name. If **autoUpdateDependencies = true** then it will update watching dependencies
           */
          get: (...args) => {
              /**
               * Auto update watching dependencies if needed
               */
              if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
                  watchingDependencies.push(args[0]);
              // eslint-disable-next-line no-unused-expressions
              touches.value; // adds reactivity to method
              return cookies.get(args[0], Object.assign({ doNotParse }, args[1]));
          },
          /**
           * Reactive get all cookies
           */
          getAll: (...args) => {
              // eslint-disable-next-line no-unused-expressions
              touches.value; // adds reactivity to method
              return cookies.getAll(Object.assign({ doNotParse }, args[0]));
          },
          set: (...args) => cookies.set(...args),
          remove: (...args) => cookies.remove(...args),
          addChangeListener: (...args) => cookies.addChangeListener(...args),
          removeChangeListener: (...args) => cookies.removeChangeListener(...args),
      };
  }
  function shouldUpdate(dependencies, newCookies, oldCookies) {
      if (!dependencies)
          return true;
      for (const dependency of dependencies) {
          if (newCookies[dependency] !== oldCookies[dependency])
              return true;
      }
      return false;
  }

  exports.createCookies = createCookies;
  exports.useCookies = useCookies;

  Object.defineProperty(exports, '__esModule', { value: true });

}(this.VueUse = this.VueUse || {}, VueUse, VueDemi, UniversalCookie));
