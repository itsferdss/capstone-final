import { shallowRef, ref, unref, watch, computed, isRef, watchEffect } from 'vue-demi';
import axios from 'axios';
import { tryOnMounted, tryOnUnmounted, isNumber, isClient } from '@vueuse/shared';
import Cookie from 'universal-cookie';
import { createFocusTrap } from 'focus-trap';
import jwt_decode from 'jwt-decode';
import nprogress from 'nprogress';
import QRCode from 'qrcode';

/**
 * Wrapper for axios.
 *
 * @see https://vueuse.org/useAxios
 * @param url
 * @param config
 */
function useAxios(url, ...args) {
    let config = {};
    let instance = axios;
    if (args.length > 0) {
        /**
         * Unable to use `instanceof` here becuase of (https://github.com/axios/axios/issues/737)
         * so instead we are checking if there is a `requset` on the object to see if it is an
         * axios instance
         */
        if ('request' in args[0])
            instance = args[0];
        else
            config = args[0];
    }
    if (args.length > 1) {
        if ('request' in args[1])
            instance = args[1];
    }
    const response = shallowRef();
    const data = shallowRef();
    const isFinished = ref(false);
    const isLoading = ref(true);
    const aborted = ref(false);
    const error = shallowRef();
    const cancelToken = axios.CancelToken.source();
    const abort = (message) => {
        if (isFinished.value || !isLoading.value)
            return;
        cancelToken.cancel(message);
        aborted.value = true;
        isLoading.value = false;
        isFinished.value = false;
    };
    instance(url, Object.assign(Object.assign({}, config), { cancelToken: cancelToken.token }))
        .then((r) => {
        response.value = r;
        data.value = r.data;
    })
        .catch((e) => {
        error.value = e;
    })
        .finally(() => {
        isLoading.value = false;
        isFinished.value = true;
    });
    return {
        response,
        data,
        error,
        finished: isFinished,
        loading: isLoading,
        isFinished,
        isLoading,
        cancel: abort,
        canceled: aborted,
        aborted,
        abort,
    };
}

/**
 * Creates a new {@link useCookies} function
 * @param {Object} req - incoming http request (for SSR)
 * @see https://github.com/reactivestack/cookies/tree/master/packages/universal-cookie universal-cookie
 * @description Creates universal-cookie instance using request (default is window.document.cookie) and returns {@link useCookies} function with provided universal-cookie instance
 */
function createCookies(req) {
    const universalCookie = new Cookie(req ? req.headers.cookie : null);
    return (dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}) => useCookies(dependencies, { doNotParse, autoUpdateDependencies }, universalCookie);
}
/**
 * Reactive methods to work with cookies (use {@link createCookies} method instead if you are using SSR)
 * @param {string[]|null|undefined} dependencies - array of watching cookie's names. Pass empty array if don't want to watch cookies changes.
 * @param {Object} options
 * @param {boolean} options.doNotParse - don't try parse value as JSON
 * @param {boolean} options.autoUpdateDependencies - automatically update watching dependencies
 * @param {Object} cookies - universal-cookie instance
 */
function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookie()) {
    const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
    let previousCookies = cookies.getAll({ doNotParse: true });
    /**
     * Adds reactivity to get/getAll methods
     */
    const touches = ref(0);
    const onChange = () => {
        const newCookies = cookies.getAll({ doNotParse: true });
        if (shouldUpdate(watchingDependencies || null, newCookies, previousCookies))
            touches.value++;
        previousCookies = newCookies;
    };
    tryOnMounted(() => {
        cookies.addChangeListener(onChange);
    });
    tryOnUnmounted(() => {
        cookies.removeChangeListener(onChange);
    });
    return {
        /**
         * Reactive get cookie by name. If **autoUpdateDependencies = true** then it will update watching dependencies
         */
        get: (...args) => {
            /**
             * Auto update watching dependencies if needed
             */
            if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
                watchingDependencies.push(args[0]);
            // eslint-disable-next-line no-unused-expressions
            touches.value; // adds reactivity to method
            return cookies.get(args[0], Object.assign({ doNotParse }, args[1]));
        },
        /**
         * Reactive get all cookies
         */
        getAll: (...args) => {
            // eslint-disable-next-line no-unused-expressions
            touches.value; // adds reactivity to method
            return cookies.getAll(Object.assign({ doNotParse }, args[0]));
        },
        set: (...args) => cookies.set(...args),
        remove: (...args) => cookies.remove(...args),
        addChangeListener: (...args) => cookies.addChangeListener(...args),
        removeChangeListener: (...args) => cookies.removeChangeListener(...args),
    };
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
    if (!dependencies)
        return true;
    for (const dependency of dependencies) {
        if (newCookies[dependency] !== oldCookies[dependency])
            return true;
    }
    return false;
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

/**
 * Get the dom element of a ref of element or Vue component instance
 *
 * @param elRef
 */
function unrefElement(elRef) {
    var _a, _b;
    const plain = unref(elRef);
    return (_b = (_a = plain) === null || _a === void 0 ? void 0 : _a.$el) !== null && _b !== void 0 ? _b : plain;
}

var SwipeDirection;
(function (SwipeDirection) {
    SwipeDirection["UP"] = "UP";
    SwipeDirection["RIGHT"] = "RIGHT";
    SwipeDirection["DOWN"] = "DOWN";
    SwipeDirection["LEFT"] = "LEFT";
    SwipeDirection["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));

/**
 * Reactive focus-trap
 *
 * @see https://vueuse.org/useFocusTrap
 * @param target The target element to trap focus within
 * @param options Focus trap options
 * @param autoFocus Focus trap automatically when mounted
 */
function useFocusTrap(target, options = {}) {
    let trap;
    const { immediate } = options, focusTrapOptions = __rest(options, ["immediate"]);
    const hasFocus = ref(false);
    const isPaused = ref(false);
    const activate = (opts) => trap && trap.activate(opts);
    const deactivate = (opts) => trap && trap.deactivate(opts);
    const pause = () => {
        if (trap) {
            trap.pause();
            isPaused.value = true;
        }
    };
    const unpause = () => {
        if (trap) {
            trap.unpause();
            isPaused.value = false;
        }
    };
    watch(() => unrefElement(target), (el) => {
        trap = createFocusTrap(el, Object.assign(Object.assign({}, focusTrapOptions), { onActivate() {
                hasFocus.value = true;
                // Apply if user provided onActivate option
                if (options.onActivate)
                    options.onActivate();
            },
            onDeactivate() {
                hasFocus.value = false;
                // Apply if user provided onDeactivate option
                if (options.onDeactivate)
                    options.onDeactivate();
            } }));
        // Focus if immediate is set to true
        if (immediate)
            activate();
    }, { flush: 'post' });
    // Cleanup on unmount
    tryOnUnmounted(() => deactivate());
    return {
        hasFocus,
        isPaused,
        activate,
        deactivate,
        pause,
        unpause,
    };
}

/**
 * Reactive decoded jwt token.
 *
 * @see https://vueuse.org/useJwt
 * @param jwt
 */
function useJwt(encodedJwt, options = {}) {
    const encodedJwtRef = ref(encodedJwt);
    const { onError, fallbackValue = null, } = options;
    const decodeWithFallback = (encodedJwt, options) => {
        try {
            return jwt_decode(encodedJwt, options);
        }
        catch (err) {
            onError === null || onError === void 0 ? void 0 : onError(err);
            return fallbackValue;
        }
    };
    const header = computed(() => decodeWithFallback(encodedJwtRef.value, { header: true }));
    const payload = computed(() => decodeWithFallback(encodedJwtRef.value));
    return {
        header,
        payload,
    };
}

/**
 * Reactive progress bar.
 *
 * @see https://vueuse.org/useNProgress
 * @param currentProgress
 * @param options
 */
function useNProgress(currentProgress = null, options) {
    const progress = isRef(currentProgress)
        ? currentProgress
        : ref(currentProgress);
    const isLoading = computed({
        set: load => load ? nprogress.start() : nprogress.done(),
        get: () => isNumber(progress.value) && progress.value < 1,
    });
    if (options)
        nprogress.configure(options);
    const setProgress = nprogress.set;
    nprogress.set = (n) => {
        progress.value = n;
        return setProgress.call(nprogress, n);
    };
    watchEffect(() => {
        if (isNumber(progress.value))
            setProgress.call(nprogress, progress.value);
    });
    tryOnUnmounted(nprogress.remove);
    return {
        isLoading,
        progress,
        start: nprogress.start,
        done: nprogress.done,
        remove: () => {
            progress.value = null;
            nprogress.remove();
        },
    };
}

/**
 * Wrapper for qrcode.
 *
 * @see https://vueuse.org/useQRCode
 * @param text
 * @param options
 */
function useQRCode(text, options) {
    const src = ref(text);
    const result = ref('');
    watch(src, async (value) => {
        if (src.value && isClient)
            result.value = await QRCode.toDataURL(value, options);
    }, { immediate: true });
    return result;
}

export { createCookies, useAxios, useCookies, useFocusTrap, useJwt, useNProgress, useQRCode };
