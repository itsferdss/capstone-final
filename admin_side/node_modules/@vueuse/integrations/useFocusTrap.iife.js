;(function (window) {
  if (window.VueDemi) {
    return
  }
  var VueDemi = {}
  var Vue = window.Vue
  if (Vue) {
    if (Vue.version.slice(0, 2) === '2.') {
      var VueCompositionAPI = window.VueCompositionAPI
      if (VueCompositionAPI) {
        for (var key in VueCompositionAPI) {
          VueDemi[key] = VueCompositionAPI[key]
        }
        VueDemi.isVue2 = true
        VueDemi.isVue3 = false
        VueDemi.install = function (){}
        VueDemi.Vue = Vue
        VueDemi.Vue2 = Vue
        VueDemi.version = Vue.version
      } else {
        console.error(
          '[vue-demi] no VueCompositionAPI instance found, please be sure to import `@vue/composition-api` before `vue-demi`.'
        )
      }
    } else if (Vue.version.slice(0, 2) === '3.') {
      for (var key in Vue) {
        VueDemi[key] = Vue[key]
      }
      VueDemi.isVue2 = false
      VueDemi.isVue3 = true
      VueDemi.install = function (){}
      VueDemi.Vue = Vue
      VueDemi.Vue2 = undefined
      VueDemi.version = Vue.version
      VueDemi.set = function(target, key, val) {
        if (Array.isArray(target)) {
          target.length = Math.max(target.length, key)
          target.splice(key, 1, val)
          return val
        }
        target[key] = val
        return val
      }
      VueDemi.del = function(target, key) {
        if (Array.isArray(target)) {
          target.splice(key, 1)
          return
        }
        delete target[key]
      }
    } else {
      console.error('[vue-demi] Vue version ' + Vue.version + ' is unsupported.')
    }
  } else {
    console.error(
      '[vue-demi] no Vue instance found, please be sure to import `vue` before `vue-demi`.'
    )
  }
  window.VueDemi = VueDemi
})(window)
;
;(function (exports, vueDemi, shared, focusTrap) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    /**
     * Get the dom element of a ref of element or Vue component instance
     *
     * @param elRef
     */
    function unrefElement(elRef) {
        var _a, _b;
        const plain = vueDemi.unref(elRef);
        return (_b = (_a = plain) === null || _a === void 0 ? void 0 : _a.$el) !== null && _b !== void 0 ? _b : plain;
    }

    var SwipeDirection;
    (function (SwipeDirection) {
        SwipeDirection["UP"] = "UP";
        SwipeDirection["RIGHT"] = "RIGHT";
        SwipeDirection["DOWN"] = "DOWN";
        SwipeDirection["LEFT"] = "LEFT";
        SwipeDirection["NONE"] = "NONE";
    })(SwipeDirection || (SwipeDirection = {}));

    /**
     * Reactive focus-trap
     *
     * @see https://vueuse.org/useFocusTrap
     * @param target The target element to trap focus within
     * @param options Focus trap options
     * @param autoFocus Focus trap automatically when mounted
     */
    function useFocusTrap(target, options = {}) {
        let trap;
        const { immediate } = options, focusTrapOptions = __rest(options, ["immediate"]);
        const hasFocus = vueDemi.ref(false);
        const isPaused = vueDemi.ref(false);
        const activate = (opts) => trap && trap.activate(opts);
        const deactivate = (opts) => trap && trap.deactivate(opts);
        const pause = () => {
            if (trap) {
                trap.pause();
                isPaused.value = true;
            }
        };
        const unpause = () => {
            if (trap) {
                trap.unpause();
                isPaused.value = false;
            }
        };
        vueDemi.watch(() => unrefElement(target), (el) => {
            trap = focusTrap.createFocusTrap(el, Object.assign(Object.assign({}, focusTrapOptions), { onActivate() {
                    hasFocus.value = true;
                    // Apply if user provided onActivate option
                    if (options.onActivate)
                        options.onActivate();
                },
                onDeactivate() {
                    hasFocus.value = false;
                    // Apply if user provided onDeactivate option
                    if (options.onDeactivate)
                        options.onDeactivate();
                } }));
            // Focus if immediate is set to true
            if (immediate)
                activate();
        }, { flush: 'post' });
        // Cleanup on unmount
        shared.tryOnUnmounted(() => deactivate());
        return {
            hasFocus,
            isPaused,
            activate,
            deactivate,
            pause,
            unpause,
        };
    }

    exports.useFocusTrap = useFocusTrap;

    Object.defineProperty(exports, '__esModule', { value: true });

}(this.VueUse = this.VueUse || {}, VueDemi, VueUse, focusTrap));
