'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var shared = require('@vueuse/shared');
var vueDemi = require('vue-demi');
var Cookie = require('universal-cookie');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Cookie__default = /*#__PURE__*/_interopDefaultLegacy(Cookie);

/**
 * Creates a new {@link useCookies} function
 * @param {Object} req - incoming http request (for SSR)
 * @see https://github.com/reactivestack/cookies/tree/master/packages/universal-cookie universal-cookie
 * @description Creates universal-cookie instance using request (default is window.document.cookie) and returns {@link useCookies} function with provided universal-cookie instance
 */
function createCookies(req) {
    const universalCookie = new Cookie__default['default'](req ? req.headers.cookie : null);
    return (dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}) => useCookies(dependencies, { doNotParse, autoUpdateDependencies }, universalCookie);
}
/**
 * Reactive methods to work with cookies (use {@link createCookies} method instead if you are using SSR)
 * @param {string[]|null|undefined} dependencies - array of watching cookie's names. Pass empty array if don't want to watch cookies changes.
 * @param {Object} options
 * @param {boolean} options.doNotParse - don't try parse value as JSON
 * @param {boolean} options.autoUpdateDependencies - automatically update watching dependencies
 * @param {Object} cookies - universal-cookie instance
 */
function useCookies(dependencies, { doNotParse = false, autoUpdateDependencies = false } = {}, cookies = new Cookie__default['default']()) {
    const watchingDependencies = autoUpdateDependencies ? [...dependencies || []] : dependencies;
    let previousCookies = cookies.getAll({ doNotParse: true });
    /**
     * Adds reactivity to get/getAll methods
     */
    const touches = vueDemi.ref(0);
    const onChange = () => {
        const newCookies = cookies.getAll({ doNotParse: true });
        if (shouldUpdate(watchingDependencies || null, newCookies, previousCookies))
            touches.value++;
        previousCookies = newCookies;
    };
    shared.tryOnMounted(() => {
        cookies.addChangeListener(onChange);
    });
    shared.tryOnUnmounted(() => {
        cookies.removeChangeListener(onChange);
    });
    return {
        /**
         * Reactive get cookie by name. If **autoUpdateDependencies = true** then it will update watching dependencies
         */
        get: (...args) => {
            /**
             * Auto update watching dependencies if needed
             */
            if (autoUpdateDependencies && watchingDependencies && !watchingDependencies.includes(args[0]))
                watchingDependencies.push(args[0]);
            // eslint-disable-next-line no-unused-expressions
            touches.value; // adds reactivity to method
            return cookies.get(args[0], Object.assign({ doNotParse }, args[1]));
        },
        /**
         * Reactive get all cookies
         */
        getAll: (...args) => {
            // eslint-disable-next-line no-unused-expressions
            touches.value; // adds reactivity to method
            return cookies.getAll(Object.assign({ doNotParse }, args[0]));
        },
        set: (...args) => cookies.set(...args),
        remove: (...args) => cookies.remove(...args),
        addChangeListener: (...args) => cookies.addChangeListener(...args),
        removeChangeListener: (...args) => cookies.removeChangeListener(...args),
    };
}
function shouldUpdate(dependencies, newCookies, oldCookies) {
    if (!dependencies)
        return true;
    for (const dependency of dependencies) {
        if (newCookies[dependency] !== oldCookies[dependency])
            return true;
    }
    return false;
}

exports.createCookies = createCookies;
exports.useCookies = useCookies;
